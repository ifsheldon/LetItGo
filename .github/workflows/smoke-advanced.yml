name: "Smoke: advanced edge cases"

# Real-tmutil smoke tests for edge cases: incremental diffs, stale cleanup,
# multiple repos, nested .gitignore, file-level patterns, init command,
# submodule-style repos, full cycle, and pattern removal.

on:
  push:
    branches: ["main"]
    paths: ["src/**", "Cargo.toml", "Cargo.lock", ".github/workflows/**"]
  pull_request:
    paths: ["src/**", "Cargo.toml", "Cargo.lock", ".github/workflows/**"]

env:
  CARGO_TERM_COLOR: always

jobs:
  smoke-advanced:
    name: Advanced smoke tests
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2

      - name: Build
        run: cargo build

      - name: Create xattr helpers
        run: |
          cat > "$RUNNER_TEMP/h.sh" <<'EOF'
          assert_xattr()    { xattr "$1" 2>/dev/null | grep -q com_apple_backup_excludeItem || { echo "FAIL: $2 — no xattr on $1"; exit 1; }; echo "OK: $2"; }
          assert_no_xattr() { if xattr "$1" 2>/dev/null | grep -q com_apple_backup_excludeItem; then echo "FAIL: $2 — xattr on $1"; exit 1; fi; echo "OK: $2"; }
          make_config() { printf 'search_paths = ["%s"]\nignored_paths = []\nwhitelist = %s\nexclusion_mode = "sticky"\n' "$1" "${2:-[]}" > "$3"; }
          EOF

      # ── Incremental diff ─────────────────────────────────────────────────────
      - name: "incremental: new dir added between runs"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/incr"
          C="$RUNNER_TEMP/incr.toml"
          mkdir -p "$R/.git" "$R/target"
          printf 'target/\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target" "incr: target/ after first run"
          # Add dist/
          mkdir -p "$R/dist"
          printf 'target/\ndist/\n' > "$R/.gitignore"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target" "incr: target/ still excluded"
          assert_xattr "$R/dist"   "incr: dist/ added incrementally"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Stale path cleanup ───────────────────────────────────────────────────
      - name: "stale: clean removes deleted dirs"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/stale"
          C="$RUNNER_TEMP/stale.toml"
          mkdir -p "$R/.git" "$R/target" "$R/node_modules"
          printf 'target/\nnode_modules/\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          BEFORE=$(./target/debug/letitgo --config "$C" list --json \
            | python3 -c "import sys,json; print(json.load(sys.stdin)['count'])")
          echo "Before: $BEFORE paths"
          # Delete one dir
          rm -rf "$R/node_modules"
          # Verify stale detection
          STALE=$(./target/debug/letitgo --config "$C" list --stale)
          echo "$STALE"
          echo "$STALE" | grep -q 'node_modules' || { echo "FAIL: stale not detected"; exit 1; }
          # Clean
          ./target/debug/letitgo --config "$C" clean
          AFTER=$(./target/debug/letitgo --config "$C" list --json \
            | python3 -c "import sys,json; print(json.load(sys.stdin)['count'])")
          echo "After: $AFTER paths"
          [ "$AFTER" -lt "$BEFORE" ] || { echo "FAIL: count did not decrease"; exit 1; }
          echo "OK: stale cleanup $BEFORE → $AFTER"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Multiple repos ───────────────────────────────────────────────────────
      - name: "multi-repo: two repos under one search path"
        run: |
          source "$RUNNER_TEMP/h.sh"
          ROOT="$RUNNER_TEMP/multi"
          C="$RUNNER_TEMP/multi.toml"
          mkdir -p "$ROOT/alpha/.git" "$ROOT/alpha/target"
          printf 'target/\n' > "$ROOT/alpha/.gitignore"
          mkdir -p "$ROOT/beta/.git" "$ROOT/beta/build"
          printf 'build/\n' > "$ROOT/beta/.gitignore"
          make_config "$ROOT" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$ROOT"
          assert_xattr "$ROOT/alpha/target" "multi: alpha/target/"
          assert_xattr "$ROOT/beta/build"   "multi: beta/build/"
          COUNT=$(./target/debug/letitgo --config "$C" list --json \
            | python3 -c "import sys,json; print(json.load(sys.stdin)['count'])")
          [ "$COUNT" -ge 2 ] || { echo "FAIL: expected >= 2, got $COUNT"; exit 1; }
          echo "OK: $COUNT paths across 2 repos"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Nested .gitignore ────────────────────────────────────────────────────
      - name: "nested .gitignore: subdirectory patterns"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/nested"
          C="$RUNNER_TEMP/nested.toml"
          mkdir -p "$R/.git" "$R/src/vendor" "$R/src/main"
          printf '' > "$R/.gitignore"
          printf 'vendor/\n' > "$R/src/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr    "$R/src/vendor" "nested: src/vendor/ excluded"
          assert_no_xattr "$R/src/main"   "nested: src/main/ not excluded"
          assert_no_xattr "$R/src"        "nested: src/ not excluded"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── File-level pattern ───────────────────────────────────────────────────
      - name: "file-level: *.log excludes files not dirs"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/filelvl"
          C="$RUNNER_TEMP/filelvl.toml"
          mkdir -p "$R/.git" "$R/logs"
          printf 'log data' > "$R/logs/debug.log"
          printf 'fn main()' > "$R/logs/app.rs"
          printf '*.log\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr    "$R/logs/debug.log" "filelvl: debug.log excluded"
          assert_no_xattr "$R/logs/app.rs"    "filelvl: app.rs not excluded"
          assert_no_xattr "$R/logs"           "filelvl: logs/ dir not excluded"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── init command ─────────────────────────────────────────────────────────
      - name: "init: create, no-overwrite, force"
        run: |
          IC="$RUNNER_TEMP/init-test.toml"
          ./target/debug/letitgo --config "$IC" init
          [ -f "$IC" ] || { echo "FAIL: not created"; exit 1; }
          grep -q 'search_paths' "$IC" || { echo "FAIL: bad content"; exit 1; }
          echo "OK: init created config"
          ORIG=$(cat "$IC")
          ./target/debug/letitgo --config "$IC" init
          [ "$(cat "$IC")" = "$ORIG" ] || { echo "FAIL: overwritten without --force"; exit 1; }
          echo "OK: init no-overwrite"
          echo '# corrupted' > "$IC"
          ./target/debug/letitgo --config "$IC" init --force
          grep -q 'search_paths' "$IC" || { echo "FAIL: --force failed"; exit 1; }
          echo "OK: init --force"

      # ── Submodule-style repo ─────────────────────────────────────────────────
      - name: "submodule: .git file (not dir)"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/submod"
          C="$RUNNER_TEMP/submod.toml"
          mkdir -p "$R" "$R/target"
          printf 'gitdir: /tmp/fake-git-dir\n' > "$R/.git"
          printf 'target/\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target" "submod: target/ excluded"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Full cycle: run → reset → re-run ────────────────────────────────────
      - name: "cycle: run → reset → re-run"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/cycle"
          C="$RUNNER_TEMP/cycle.toml"
          mkdir -p "$R/.git" "$R/target" "$R/node_modules"
          printf 'target/\nnode_modules/\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          # Run
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target"       "cycle-1: target/"
          assert_xattr "$R/node_modules" "cycle-1: node_modules/"
          # Reset
          ./target/debug/letitgo --config "$C" reset --yes
          assert_no_xattr "$R/target"       "cycle-reset: target/"
          assert_no_xattr "$R/node_modules" "cycle-reset: node_modules/"
          # Re-run
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target"       "cycle-2: target/"
          assert_xattr "$R/node_modules" "cycle-2: node_modules/"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Removal: drop pattern between runs ──────────────────────────────────
      - name: "removal: un-exclude when pattern dropped from .gitignore"
        run: |
          source "$RUNNER_TEMP/h.sh"
          R="$RUNNER_TEMP/removal"
          C="$RUNNER_TEMP/removal.toml"
          mkdir -p "$R/.git" "$R/target" "$R/node_modules"
          printf 'target/\nnode_modules/\n' > "$R/.gitignore"
          make_config "$R" "[]" "$C"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_xattr "$R/target"       "removal-1: target/"
          assert_xattr "$R/node_modules" "removal-1: node_modules/"
          # Drop target/ from .gitignore
          printf 'node_modules/\n' > "$R/.gitignore"
          ./target/debug/letitgo --config "$C" run --search-path "$R"
          assert_no_xattr "$R/target"       "removal-2: target/ un-excluded"
          assert_xattr    "$R/node_modules" "removal-2: node_modules/ kept"
          ./target/debug/letitgo --config "$C" reset --yes 2>/dev/null || true

      # ── Cleanup ──────────────────────────────────────────────────────────────
      - name: Cleanup
        if: always()
        run: |
          if [ -f ./target/debug/letitgo ]; then
            for c in "$RUNNER_TEMP"/*.toml; do
              [ -f "$c" ] && ./target/debug/letitgo --config "$c" reset --yes 2>/dev/null || true
            done
          fi
