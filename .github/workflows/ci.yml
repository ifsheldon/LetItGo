name: CI

on:
  push:
    branches: ["main"]
    paths:
      - "src/**"
      - "Cargo.toml"
      - "Cargo.lock"
  pull_request:
    paths:
      - "src/**"
      - "Cargo.toml"
      - "Cargo.lock"

env:
  CARGO_TERM_COLOR: always

jobs:
  # ── Lint: formatting and clippy ───────────────────────────────────────────────
  lint:
    name: Lint (fmt + clippy)
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - uses: Swatinem/rust-cache@v2

      - name: cargo fmt --check
        run: cargo fmt --check

      - name: cargo clippy
        run: cargo clippy -- -D warnings

  # ── macOS: unit tests + real tmutil integration ───────────────────────────────
  #
  # GitHub-hosted macOS runners (macos-latest = macOS 15 arm64) include tmutil
  # and allow `addexclusion` / `removeexclusion` in sticky mode (xattr-based)
  # without sudo or TCC permissions.  No real Time Machine destination is needed.
  #
  # Fixed-path mode (`-p`) writes to /Library/Preferences/com.apple.TimeMachine.plist
  # and is NOT tested here because it requires root. Sticky mode is the default.
  #
  # NOTE — why we check xattrs instead of `tmutil isexcluded`:
  # GitHub Actions pre-excludes broad path trees (including $HOME and $RUNNER_TEMP)
  # by setting the com.apple.metadata:com_apple_backup_excludeItem xattr on ancestor
  # directories.  `tmutil isexcluded` inherits from parents, so it reports every
  # path underneath as [Excluded] regardless of whether letitgo touched it.
  # Reading the xattr directly on the specific item is authoritative:
  #   - a newly created directory has no xattr → "not excluded" baseline is clean
  #   - `tmutil addexclusion` sets the xattr on the exact path → detectable
  #   - `tmutil removeexclusion` removes it → post-reset state is verifiable
  macos:
    name: macOS tests + real tmutil
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2

      # ── 1. Build + run all unit + integration tests (MockExclusionManager) ──
      - name: cargo build (debug binary for integration tests)
        run: cargo build

      - name: cargo test (macOS)
        run: cargo test

      # ── 2. Set up a fake git repo for real-tmutil tests ──────────────────────
      #
      # We use $RUNNER_TEMP so paths are absolute, which tmutil requires.
      # Two gitignored directories are created so we can verify both are excluded.
      - name: Set up fake git repo
        run: |
          REPO="$RUNNER_TEMP/letitgo-test-repo"
          mkdir -p "$REPO/.git"
          mkdir -p "$REPO/target/debug"
          mkdir -p "$REPO/target/release"
          mkdir -p "$REPO/node_modules/lodash"
          printf 'target/\nnode_modules/\n' > "$REPO/.gitignore"
          echo "REPO=$REPO" >> "$GITHUB_ENV"

      # Write a config that scopes the scan to our fake repo only,
      # with no whitelist entries and sticky (xattr) exclusion mode.
      - name: Write letitgo config
        run: |
          CFG="$RUNNER_TEMP/letitgo-test-config.toml"
          cat > "$CFG" <<EOF
          search_paths = ["$REPO"]
          ignored_paths = []
          whitelist = []
          exclusion_mode = "sticky"
          EOF
          echo "CFG=$CFG" >> "$GITHUB_ENV"

      # ── 3. Dry-run: verify no real tmutil calls are made ─────────────────────
      - name: letitgo run --dry-run (no exclusions should be set)
        run: ./target/debug/letitgo --config "$CFG" --dry-run run --search-path "$REPO"

      - name: Verify dry-run left no exclusion xattr on target/
        run: |
          if xattr "$REPO/target" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr was set but --dry-run should not touch tmutil"
            exit 1
          fi
          echo "OK: no exclusion xattr on target/"

      - name: Verify dry-run left no exclusion xattr on node_modules/
        run: |
          if xattr "$REPO/node_modules" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr was set but --dry-run should not touch tmutil"
            exit 1
          fi
          echo "OK: no exclusion xattr on node_modules/"

      # ── 4. Real run: letitgo calls tmutil addexclusion ────────────────────────
      - name: letitgo run (adds exclusions via real tmutil)
        run: ./target/debug/letitgo --config "$CFG" run --search-path "$REPO"

      - name: Verify exclusion xattr is set on target/
        run: |
          if ! xattr "$REPO/target" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr is absent — tmutil addexclusion did not fire"
            exit 1
          fi
          echo "OK: exclusion xattr present on target/"

      - name: Verify exclusion xattr is set on node_modules/
        run: |
          if ! xattr "$REPO/node_modules" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr is absent — tmutil addexclusion did not fire"
            exit 1
          fi
          echo "OK: exclusion xattr present on node_modules/"

      # ── 5. list command ───────────────────────────────────────────────────────
      - name: letitgo list (plain text)
        run: ./target/debug/letitgo --config "$CFG" list

      - name: letitgo list --json (verify path count >= 2)
        run: |
          COUNT=$(./target/debug/letitgo --config "$CFG" list --json \
            | python3 -c "import sys,json; print(json.load(sys.stdin)['count'])")
          echo "Excluded path count: $COUNT"
          [ "$COUNT" -ge 2 ]

      - name: letitgo list --stale (all paths exist — should report none stale)
        run: ./target/debug/letitgo --config "$CFG" list --stale

      # ── 6. clean command (no stale paths — all dirs still exist) ─────────────
      - name: letitgo clean (should report no stale paths)
        run: ./target/debug/letitgo --config "$CFG" clean

      # ── 7. Second run: idempotency (diff should be empty) ────────────────────
      #
      # The cache already matches the current state, so no tmutil calls are made.
      - name: letitgo run second time (idempotent — nothing changes)
        run: ./target/debug/letitgo --config "$CFG" run --search-path "$REPO"

      - name: Verify exclusion xattr still set on target/ after second run
        run: |
          if ! xattr "$REPO/target" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr was unexpectedly removed"
            exit 1
          fi
          echo "OK: exclusion xattr still present after idempotent run"

      # ── 8. Reset: removes all exclusions and clears the cache ─────────────────
      - name: letitgo reset --yes
        run: ./target/debug/letitgo --config "$CFG" reset --yes

      - name: Verify exclusion xattr removed from target/ after reset
        run: |
          if xattr "$REPO/target" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr still present after reset"
            exit 1
          fi
          echo "OK: exclusion xattr removed from target/"

      - name: Verify exclusion xattr removed from node_modules/ after reset
        run: |
          if xattr "$REPO/node_modules" 2>/dev/null | grep -q 'com_apple_backup_excludeItem'; then
            echo "FAIL: exclusion xattr still present after reset"
            exit 1
          fi
          echo "OK: exclusion xattr removed from node_modules/"

      - name: letitgo list (should show empty cache after reset)
        run: ./target/debug/letitgo --config "$CFG" list

      # ── 9. Cleanup: always run in case any step above fails ──────────────────
      #
      # If an earlier step failed while exclusions were set, this ensures the
      # runner is left clean.  Errors are suppressed since the binary or config
      # may not exist if the build itself failed.
      - name: Cleanup — remove any lingering exclusions
        if: always()
        run: |
          if [ -f ./target/debug/letitgo ] && [ -n "${CFG:-}" ]; then
            ./target/debug/letitgo --config "$CFG" reset --yes 2>/dev/null || true
          fi
